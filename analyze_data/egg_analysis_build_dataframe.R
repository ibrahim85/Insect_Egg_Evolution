### Created by SHC, April 2018

### This code reads in the raw egg database and creates a 
### dataframe with the final measurements used in the 
### downstream analyses.

library(RColorBrewer)
library(plyr)
library(dplyr)
library(ggplot2)
theme_set(theme_classic(base_size=18))
rad2deg <- function(rad) {(rad * 180) / (pi)}
deg2rad <- function(deg) {(deg * pi) / (180)}

### Read in the raw values from the egg database

# read in the tab delimited database, generated by convert_database.py 
egg_database_raw <- read.delim("egg_database.csv",stringsAsFactors=F) 

egg_database_filtered <- egg_database_raw %>% filter(
            # filter out the entries with problems in taxonomy
            !(problem %in% c("no_name","no_taxonomy","order")))

### Assemble the egg dataset used for analysis

# this tower of piped commands creates the dataframe used for all subsequent analyses
# this dataframe is called egg database with duplicates, because it includes all entries including repeated descriptions (e.g. from a review of a subsequent publication)

egg_database_w_duplicates <- egg_database_filtered %>% mutate(
            # X1 is the "length" measurement
            # we select the average length, if it is available
            # otherwise, we select the midpoint of the range of lengths, if available
            # otherwise, we select the single point estimate of length
            txtX1 = ifelse(!is.na(al), 
                al, 
                ifelse(!is.na(ml), 
                    xl - ((xl - ml)/2), 
                    pl)),
            # these commands identify if there is a single diameter reported
            # or two diameters (width and breadth)
            # if so, we choose the larger of the two to use as X2 (width)
            # the same logic as above applies here
            txt_w = ifelse(!is.na(aw), 
                    aw, 
                    ifelse(!is.na(mw), 
                        xw - ((xw - mw)/2), 
                        pw)),
            txt_b = ifelse(!is.na(ab), 
                    ab, 
                    ifelse(!is.na(mb), 
                        xb - ((xb - mb)/2), 
                        pb)),
            txtX2 = pmax(txt_b,txt_w,na.rm=T),
            # if there was a second diameter, this is stored as X3
            X3 = ifelse(!is.na(txt_b),
                pmin(txt_b,txt_w,na.rm=T),
                NA),
            # these commands get the maximum width from 3 quartiles of image measurement
            imX2 = ifelse(!is.na(im_length_1st_quart_mm),
                pmax(im_length_1st_quart_mm,im_length_3rd_quart_mm,im_width),
                im_width),
            imX2px = ifelse(!is.na(im_length_1st_quart_px),
                pmax(im_length_1st_quart_px,im_length_3rd_quart_px,im_width),
                im_width),
            # these commands rename the varaibles into those used downstream in R analyses
            ) %>% rename(
            # bibliography ID
            bibtex = b,
            # taxonomic information
            order = tax_order,
            suborder = tax_suborder,
            superfamily = tax_superfamily,
            subfamily = tax_subfamily,
            family = tax_family,
            tribe = tax_tribe,
            genus = cg,
            species = cs,
            # publication details
            year = bib_year,
            author = bib_author,
            journal = bib_journal,
            # report on image (available, processed,etc)
            image = im_status,
            # measurements from image, if available
            imX1 = im_length_straight,
            imX1px = im_length_straight_px,
            asym = im_asym,
            curv = im_curvature_rad
            # these commands transform the data
            # this includes calculating volume, log transformations, etc.
            ) %>% mutate(
            # underscores added to names
            name = gsub(" ","_",tax_matched),
            # calculating volume
            # if the volume was reported in the text, it is used
            # otherwise volume is calculated as a prolate ellipsoid
            txtvol = ifelse(!is.na(av), 
                av, 
                ifelse(!is.na(mv), 
                    xv - ((xv - mv)/2), 
                    ifelse(!is.na(pv), 
                        pv,
            # if breadth is available it is used in the volume equation
            # otherwise, the egg is considered to be rotationally symmetric
            # the equation for a prolate ellipsoid is:
            #     4/3 * pi * l/2 * r^2
                        ifelse(!is.na(X3),
                            ((4/3) * pi * (txtX1/2) * (txtX2/2) * (X3/2)),
                            ((4/3) * pi * (txtX1/2) * (txtX2/2)^2))))),
            # calculating aspect ratio
            txtar = (txtX1 / txtX2),
            # calculating volume and aspect ratio from image measurements
            imvol = ((4/3) * pi * (imX1/2) * (imX2/2)^2),
            imar = ifelse(!is.na(imX1),
                        imX1 / imX2,
                        imX1px / imX2px),
            # calculate ellipticity as defined by Baker, Stoddard
            txtel = txtar - 1,
            imel = imar - 1,
            # calculate asymmetry as ratio - 1,
            asym = asym - 1,
            # log10 transformations
            logtxtar = log10(txtar),
            logtxtX1 = log10(txtX1),
            logtxtX2 = log10(txtX2),
            logX3 = log10(X3),
            logtxtvol = log10(txtvol),
            logimX1 = log10(imX1),
            logimX2 = log10(imX2),
            logimvol = log10(imvol),
            logimar = log10(imar),
            sqasym = sqrt(asym),
            sqcurv = sqrt(curv)
            # these final transformations select the main measurements used downstream
            ) %>% mutate(
            # text measurements are prioritized over images
            X1 = ifelse(!is.na(txtX1), txtX1, imX1),
            X2 = ifelse(!is.na(txtX2), txtX2, imX2),
            vol = ifelse(!is.na(txtvol), txtvol, imvol),
            ar = ifelse(!is.na(txtar), txtar, imar),
            el = ifelse(!is.na(txtel), txtel, imel),
            logX1 = ifelse(!is.na(logtxtX1), logtxtX1, logimX1),
            logX2 = ifelse(!is.na(logtxtX2), logtxtX2, logimX2),
            logvol = ifelse(!is.na(logtxtvol), logtxtvol, logimvol),
            logar = ifelse(!is.na(logtxtar), logtxtar, logimar),
            # the following remove values found to be error prone
            # if aspect ratio is 1 or below, curvature is not measured accurately
            # here we set curvature to NA for those eggs
            curv = ifelse(ar <= 1, NA, curv),
            sqcurv = ifelse(ar <= 1, NA, sqcurv),
            # here we remove the eggs with the highest asymmetry and aspect ratio
            # these are found to have the highest shape measurement error
            ) %>% filter(ar < quantile(na.omit(ar),0.999) | is.na(ar)
            ) %>% filter(asym < quantile(na.omit(asym),0.999) | is.na(asym)
            # these commands select the relevant columns, all others will be set aside
            ) %>% select(
                ID,bibtex,author,journal,year,
                family,superfamily,subfamily,suborder,order,tribe,genus,species,
                name,image,
                txtX1,txtX2,txtvol,txtar,txtel,logtxtar,logtxtX1,logtxtX2,logtxtvol,
                imX1,imX2,logimX1,logimX2,imvol,imar,imel,logimar,asym,curv,sqasym,sqcurv,
                X1,X2,X3,logX1,logX2,logX3,ar,el,vol,logar,logvol
            )


### this code removes entries which have the same reported
### volume for a taxon from two entries

### these are likely publications which repeat a previous
### observation of an egg (like a review)

### note: only removed duplicates with text reported volume
###     there could be other duplicated with only length or width 
###     but these will not affect downstream analyses

dup_names <- egg_database_w_duplicates %>% 
    # get entries with some text data on egg size
    filter(!(is.na(txtvol))) %>% 
    # find those with duplicate names
    filter(duplicated(name)) %>% 
    pull(name)

dup_diff_txtvol <- egg_database_w_duplicates %>% 
    # pull out entries with duplicated names
    filter(name %in% dup_names) %>%
    # calculate the difference in the text reported volume 
    group_by(name) %>% 
    summarise(diff = max(txtvol - min(txtvol))) %>% 
    # filter those with a difference below 0.00001
    filter(diff < (0.1 * 10^-5)) %>% 
    select(name,diff)

choose_duplicated <- egg_database_w_duplicates %>%
    # pull out entries which are likely reviews
    filter(name %in% dup_diff_txtvol$name) %>% 
    group_by(name) %>% 
    # find the most recent publication
    arrange(name,desc(year)) %>% 
    slice(-1L) %>% pull(ID)

# filter out likely review entries
egg_database <- egg_database_w_duplicates %>% 
    filter(!(ID %in% choose_duplicated))

# this code groups the entries into 8 major groups of insects
# the information for grouping is stored in an external dictionary
# this is primarily used to color plots
groups <- read.delim("analyze_data/groups_orders.txt",stringsAsFactors=F)
egg_database$group <- mapvalues(egg_database$order,groups$order,groups$group,warn_missing=F)

### Print the database
#write.table(egg_database,file="formatted_egg_database.csv",row.names=F,sep="\t")
#write.table(egg_database_raw %>% dplyr::select('ID','ab','al','av','aw','b','bib_address','bib_author','bib_booktitle','bib_journal','bib_number','bib_pages','bib_publisher','bib_pubstate','bib_school','bib_title','bib_volume','bib_year','cg','cs','db','dl','dv','dw','g','i','im_asym','im_curvature_deg','im_curvature_rad','im_length_1st_quart_mm','im_length_1st_quart_px','im_length_3rd_quart_mm','im_length_3rd_quart_px','im_length_curved','im_length_curved_px','im_length_straight','im_length_straight_px','im_magnification','im_mm_per_px','im_sb_length_mm','im_sb_length_px','im_status','im_width','im_width_px','mb','ml','mv','mw','pb','pl','pv','pw','s','subspecies','tax_cg_ncbi_id','tax_cg_ott_accepted_name','tax_cg_ott_id','tax_class','tax_cs_ncbi_id','tax_cs_ott_id','tax_family','tax_genus','tax_higher_source','tax_infraclass','tax_infraorder','tax_matched','tax_matched_id_in_source','tax_name_source','tax_order','tax_ott_version','tax_parvorder','tax_score','tax_section','tax_species.group','tax_species.subgroup','tax_subclass','tax_subfamily','tax_subgenus','tax_suborder','tax_subphylum','tax_subtribe','tax_superfamily','tax_superorder','tax_taxonomy_source','tax_tribe','xb','xl','xv','xw'),file="unformatted_egg_database.csv",row.names=F,sep="\t")

# this sets the color dictionary for all future plots by group
marker <- brewer.pal(n = 8, name = "Set1")
marker <- marker[c(1:5,7:8)]
mrk <- c("Hymenoptera" = "#BE0000",
"Condylognatha" = "#2E9B00",
"Psocodea" = "#878787",
"Antliophora" = "#2056CE",
"Neuropteroidea" = "#E87425",
"Amphiesmenoptera" = "#22CED5",
"Polyneoptera" = "#D454E2",
"Palaeoptera" = "#F2C406",
"Apterygota" = "#3A175F",
"Aves" = "#000000")

#group_levels = c("Apterygotaerygota","Palaeoptera","Polyneoptera","Condylognatha","Hymenoptera","Neuropteroidea","Amphiesmenoptera","Antliophora")
group_levels = c("Apterygota","Palaeoptera","Polyneoptera","Condylognatha","Psocodea","Hymenoptera","Neuropteroidea","Amphiesmenoptera","Antliophora","Aves")

# Print summary statistics
#egg_database_raw$group <- mapvalues(egg_database_raw$tax_order,groups$order,groups$group,warn_missing=F)
#write.table(sep="\t",col.names=F,row.names=F,file = "egg_database_entries_statistics.txt",egg_database_raw %>% group_by(group) %>% mutate(n = n()) %>% slice(1L) %>% select(group,n))

##### This code was used to clean up the database, one time only

### identify entries with no egg data at all

### # IDs of entries wihtout text data
### no_txt_data <- egg_database %>% 
###     select(txtX1,txtX2,txtvol,ID) %>% 
###     mutate(sum = rowSums(is.na(.))) %>% 
###     filter(sum == 3) %>% 
###     pull(ID)
### 
### # IDs of entries without text or image data
### no_data <- egg_database %>% 
###     filter(ID %in% no_txt_data) %>% 
###     filter(image %in% c("missing","none","")) %>% 
###     pull(ID)

### identify duplicate entries from parsing

### egg_tag <- egg_database_raw %>% 
###     mutate(tag = paste(g,s,b))
### 
### distinct <- egg_tag %>% 
###     distinct(tag,.keep_all=T) %>% 
###     pull(ID)
### 
### not_distinct <- egg_tag %>% 
###     filter(!(ID %in% distinct)) %>% 
###     pull(tag)
### 
### doubles <- egg_tag %>% 
###     filter(tag %in% not_distinct) %>% 
###     select(g,s,b,subspecies,im_status,ID,pl,pw,pv) %>% 
###     arrange(b,g,s)
### 
### write.table(doubles,file="doubles.txt",sep="\t")





