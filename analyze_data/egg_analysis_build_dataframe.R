### Created by SHC, April 2018

### This code reads in the raw egg database and creates a 
### dataframe with the final measurements used in the 
### downstream analyses.

library(RColorBrewer)
library(plyr)
library(dplyr)
library(ggplot2)
theme_set(theme_classic(base_size=18))
rad2deg <- function(rad) {(rad * 180) / (pi)}
deg2rad <- function(deg) {(deg * pi) / (180)}

### Read in the raw values from the egg database

# read in the tab delimited database, generated by convert_database.py 
egg_database_raw <- read.delim("egg_database.csv",stringsAsFactors=F) 

egg_database_filtered <- egg_database_raw %>% filter(
            # filter out the entries with problems in taxonomy
            !(problem %in% c("no_name","no_taxonomy","order")))

### Assemble the egg dataset used for analysis

# this tower of piped commands creates the dataframe used for all subsequent analyses
# this dataframe is called all_med, because it includes all entries, and uses the median of measurements
egg_database_w_duplicates <- egg_database_filtered %>% mutate(
            # X1 is the "length" measurement
            # we select the average length, if it is available
            # otherwise, we select the midpoint of the range of lengths, if available
            # otherwise, we select the single point estimate of length
            txtX1 = ifelse(!is.na(al), 
                al, 
                ifelse(!is.na(ml), 
                    xl - ((xl - ml)/2), 
                    pl)),
            # these commands identify if there is a single diameter reported
            # or two diameters (width and breadth)
            # if so, we choose the larger of the two to use as X2 (width)
            # the same logic as above applies here
            txt_w = ifelse(!is.na(aw), 
                    aw, 
                    ifelse(!is.na(mw), 
                        xw - ((xw - mw)/2), 
                        pw)),
            txt_b = ifelse(!is.na(ab), 
                    ab, 
                    ifelse(!is.na(mb), 
                        xb - ((xb - mb)/2), 
                        pb)),
            txtX2 = pmax(txt_b,txt_w,na.rm=T),
            # if there was a second diameter, this is stored as X3
            X3 = ifelse(!is.na(txt_b),
                pmin(txt_b,txt_w,na.rm=T),
                NA),
            # these commands get the maximum width from 3 quartiles of image measurement
            imX2 = ifelse(!is.na(im_length_1st_quart_mm),
                pmax(im_length_1st_quart_mm,im_length_3rd_quart_mm,im_width),
                im_width),
            imX2px = ifelse(!is.na(im_length_1st_quart_px),
                pmax(im_length_1st_quart_px,im_length_3rd_quart_px,im_width),
                im_width),
            # these commands rename the varaibles into those used downstream in R analyses
            ) %>% rename(
            # bibliography ID
            bibtex = b,
            # taxonomic information
            order = tax_order,
            suborder = tax_suborder,
            superfamily = tax_superfamily,
            subfamily = tax_subfamily,
            family = tax_family,
            tribe = tax_tribe,
            genus = cg,
            species = cs,
            # publication year
            year = bib_year,
            # report on image (available, processed,etc)
            image = im_status,
            # measurements from image, if available
            imX1 = im_length_straight,
            imX1px = im_length_straight_px,
            asym = im_asym,
            curv = im_curvature_rad
            # these commands transform the data
            # this includes calculating volume, log transformations, etc.
            ) %>% mutate(
            # underscores added to names
            name = gsub(" ","_",tax_matched),
            new_name = paste(genus,species,sep="_"),
            # calculating volume
            # if the volume was reported in the text, it is used
            # otherwise volume is calculated as a prolate ellipsoid
            txtvol = ifelse(!is.na(av), 
                av, 
                ifelse(!is.na(mv), 
                    xv - ((xv - mv)/2), 
                    ifelse(!is.na(pv), 
                        pv,
            # if breadth is available it is used in the volume equation
            # otherwise, the egg is considered to be rotationally symmetric
            # the equation for a prolate ellipsoid is:
            #     4/3 * pi * l/2 * r^2
                        ifelse(!is.na(X3),
                            ((4/3) * pi * (txtX1/2) * (txtX2/2) * (X3/2)),
                            ((4/3) * pi * (txtX1/2) * (txtX2/2)^2))))),
            # calculating aspect ratio
            txtar = (txtX1 / txtX2),
            # calculating volume and aspect ratio from image measurements
            imvol = ((4/3) * pi * (imX1/2) * (imX2/2)^2),
            imar = ifelse(!is.na(imX1),
                        imX1 / imX2,
                        imX1px / imX2px),
            # calculate ellipticity as defined by Baker, Stoddard
            txtel = txtar - 1,
            imel = imar - 1,
            # calculate asymmetry as ratio - 1,
            asym = asym - 1,
            # log10 transformations
            logtxtar = log10(txtar),
            logtxtX1 = log10(txtX1),
            logtxtX2 = log10(txtX2),
            logX3 = log10(X3),
            logtxtvol = log10(txtvol),
            logimX1 = log10(imX1),
            logimX2 = log10(imX2),
            logimvol = log10(imvol),
            logimar = log10(imar),
            sqasym = sqrt(asym),
            sqcurv = sqrt(curv)
            # these final transformations select the main measurements used downstream
            ) %>% mutate(
            # text measurements are prioritized over images
            X1 = ifelse(!is.na(txtX1), txtX1, imX1),
            X2 = ifelse(!is.na(txtX2), txtX2, imX2),
            vol = ifelse(!is.na(txtvol), txtvol, imvol),
            ar = ifelse(!is.na(txtar), txtar, imar),
            el = ifelse(!is.na(txtel), txtel, imel),
            logX1 = ifelse(!is.na(logtxtX1), logtxtX1, logimX1),
            logX2 = ifelse(!is.na(logtxtX2), logtxtX2, logimX2),
            logvol = ifelse(!is.na(logtxtvol), logtxtvol, logimvol),
            logar = ifelse(!is.na(logtxtar), logtxtar, logimar),
            # the following remove values found to be error prone
            # if aspect ratio is 1 or below, curvature is not measured accurately
            # here we set curvature to NA for those eggs
            curv = ifelse(ar <= 1, NA, curv),
            sqcurv = ifelse(ar <= 1, NA, sqcurv),
            # here we remove the eggs with the highest asymmetry and aspect ratio
            # these are found to have the highest shape measurement error
            ) %>% filter(ar < quantile(na.omit(ar),0.999) | is.na(ar)
            ) %>% filter(asym < quantile(na.omit(asym),0.999) | is.na(asym)
            # these commands select the relevant columns, all others will be set aside
            ) %>% select(
                ID,bibtex,family,superfamily,subfamily,suborder,order,tribe,genus,species,
                name,new_name,year,image,
                txtX1,txtX2,txtvol,txtar,txtel,logtxtar,logtxtX1,logtxtX2,logtxtvol,
                imX1,imX2,logimX1,logimX2,imvol,imar,imel,logimar,asym,curv,sqasym,sqcurv,
                X1,X2,X3,logX1,logX2,logX3,ar,el,vol,logar,logvol
            )

### this code removes entries which have the same reported
### volume for a taxon from two entries

### these are likely publications which repeat a previous
### observation of an egg (like a review)

### note: only removed duplicates with text reported volume
###     there could be other duplicated with only length or width 
###     but these will not affect downstream analyses

dup_names <- egg_database_w_duplicates %>% 
    # get entries with some text data on egg size
    filter(!(is.na(txtvol))) %>% 
    # find those with duplicate names
    filter(duplicated(name)) %>% 
    pull(name)

dup_diff_txtvol <- egg_database_w_duplicates %>% 
    # pull out entries with duplicated names
    filter(name %in% dup_names) %>%
    # calculate the difference in the text reported volume 
    group_by(name) %>% 
    summarise(diff = max(txtvol - min(txtvol))) %>% 
    # filter those with a difference below 0.00001
    filter(diff < (0.1 * 10^-5)) %>% 
    select(name,diff)

choose_duplicated <- egg_database_w_duplicates %>%
    # pull out entries which are likely reviews
    filter(name %in% dup_diff_txtvol$name) %>% 
    group_by(name) %>% 
    # find the most recent publication
    arrange(name,desc(year)) %>% 
    slice(-1L) %>% pull(ID)

# filter out likely review entries
egg_database <- egg_database_w_duplicates %>% 
    filter(!(ID %in% choose_duplicated))

# this code groups the entries into 8 major groups of insects
# the information for grouping is stored in an external dictionary
# this is primarily used to color plots
groups <- read.delim("analyze_data/groups_orders.txt",stringsAsFactors=F)
egg_database$group <- mapvalues(egg_database$order,groups$order,groups$group,warn_missing=F)

# this sets the color dictionary for all future plots by group
marker <- brewer.pal(n = 8, name = "Set1")
marker <- marker[c(1:5,7:8)]
mrk <- c("Hymenoptera" = "#BE0000",
"Condylognatha" = "#2E9B00",
"Psocodea" = "#878787",
"Antliophora" = "#2056CE",
"Neuropteroidea" = "#E87425",
"Amphiesmenoptera" = "#22CED5",
"Polyneoptera" = "#D454E2",
"Palaeoptera" = "#F2C406",
"Apterygota" = "#3A175F",
"Aves" = "#000000")

#group_levels = c("Apterygotaerygota","Palaeoptera","Polyneoptera","Condylognatha","Hymenoptera","Neuropteroidea","Amphiesmenoptera","Antliophora")
group_levels = c("Apterygota","Palaeoptera","Polyneoptera","Condylognatha","Psocodea","Hymenoptera","Neuropteroidea","Amphiesmenoptera","Antliophora","Aves")

# Print summary statistics
#egg_database_raw$group <- mapvalues(egg_database_raw$tax_order,groups$order,groups$group,warn_missing=F)
#write.table(sep="\t",col.names=F,row.names=F,file = "egg_database_entries_statistics.txt",egg_database_raw %>% group_by(group) %>% mutate(n = n()) %>% slice(1L) %>% select(group,n))

##### This code was used to clean up the database, one time only

### identify entries with no egg data at all

### # IDs of entries wihtout text data
### no_txt_data <- egg_database %>% 
###     select(txtX1,txtX2,txtvol,ID) %>% 
###     mutate(sum = rowSums(is.na(.))) %>% 
###     filter(sum == 3) %>% 
###     pull(ID)
### 
### # IDs of entries without text or image data
### no_data <- egg_database %>% 
###     filter(ID %in% no_txt_data) %>% 
###     filter(image %in% c("missing","none","")) %>% 
###     pull(ID)

### identify duplicate entries from parsing

### egg_tag <- egg_database_raw %>% 
###     mutate(tag = paste(g,s,b))
### 
### distinct <- egg_tag %>% 
###     distinct(tag,.keep_all=T) %>% 
###     pull(ID)
### 
### not_distinct <- egg_tag %>% 
###     filter(!(ID %in% distinct)) %>% 
###     pull(tag)
### 
### doubles <- egg_tag %>% 
###     filter(tag %in% not_distinct) %>% 
###     select(g,s,b,subspecies,im_status,ID,pl,pw,pv) %>% 
###     arrange(b,g,s)
### 
### write.table(doubles,file="doubles.txt",sep="\t")


### Assemble alternative datasets
### egg_database_big <- egg_database_filtered %>% mutate(
###             # length is maximum value from average + one deviation, range, single record, or measured image
###             X1 = pmax(al + dl,xl,pl,im_length_straight,na.rm=T),
###             # text width and breadth is maximum between average + one deviation, range, and single record
###             txt_w = pmax(aw + dw,xw,pw,na.rm=T),
###             txt_b = pmax(ab + db,xb,pb,na.rm=T),
###             # width is maximum value between text width, text breadth, and image width
###             txtX2 = pmax(txt_w,txt_b,na.rm=T),
###             X2 = pmax(txtX2,im_width,na.rm=T),
###             # breadth is smaller of the text width and text breadth, (if recorded)
###             X3 = ifelse(!is.na(txt_b),
###                 pmin(txt_b,txt_w,na.rm=T),
###                 NA),
###             # calculate volume as the maximum value, either including breadth (if recorded), without breadth, or from text volume record
###             vol = pmax(((4/3) * pi * (X1/2) * (X2/2) * (X3/2)),
###                     ((4/3) * pi * (X1/2) * (X2/2)^2),
###                     av + dv, xv, pv,na.rm=T),
###             # calculate image aspect ratio
###             imar = ifelse(!is.na(im_length_straight),
###                         im_length_straight / im_width,
###                         im_length_straight_px / im_width_px),
###             # aspect ratio is the larger of the text and image values 
###             ar = pmax((X1 / X2),imar),
###             # calculate ellipticity
###             el = ar - 1,
###             # transform the data
###             logX1 = log10(X1),
###             logX2 = log10(X2),
###             logX3 = log10(X3),
###             logvol = log10(vol),
###             logar = log10(ar)
###             # select only the variables that are subject to change in large egg dataset
###             ) %>% select(
###             ID,X1,X2,X3,vol,ar,el,logX1,logX2,logX3,logvol,logar)
### 
### egg_database_small <- egg_database_filtered %>% mutate(
###             # length is minimum value from average + one deviation, range, single record, or measured image
###             X1 = pmin(al - dl,ml,pl,im_length_straight,na.rm=T),
###             # text width and breadth is minimum between average + one deviation, range, and single record
###             txt_w = pmin(aw - dw,mw,pw,na.rm=T),
###             txt_b = pmin(ab - db,mb,pb,na.rm=T),
###             # text width is maximum value between text width, text breadth, and image width
###             txtX2 = pmax(txt_w,txt_b,na.rm=T),
###             # width is minimum value between text width, text breadth, and image width
###             X2 = pmin(txtX2,im_width,na.rm=T),
###             # breadth is smaller of the text width and text breadth, (if recorded)
###             X3 = ifelse(!is.na(txt_b),
###                 pmin(txt_b,txt_w,na.rm=T),
###                 NA),
###             # calculate volume as the minimum value, either including breadth (if recorded), without breadth, or from text volume record
###             vol = pmin(((4/3) * pi * (X1/2) * (X2/2) * (X3/2)),
###                     ((4/3) * pi * (X1/2) * (X2/2)^2),
###                     av - dv, mv, pv,na.rm=T),
###             # calculate image aspect ratio
###             imar = ifelse(!is.na(im_length_straight),
###                         im_length_straight / im_width,
###                         im_length_straight_px / im_width_px),
###             # aspect ratio is the smaller of the text and image values 
###             ar = pmin((X1 / X2),imar),
###             # calculate ellipticity
###             el = ar - 1,
###             # transform the data
###             logX1 = log10(X1),
###             logX2 = log10(X2),
###             logX3 = log10(X3),
###             logvol = log10(vol),
###             logar = log10(ar)
###             # select only the variables that are subject to change in small egg dataset
###             ) %>% select(
###             ID,X1,X2,X3,vol,ar,el,logX1,logX2,logX3,logvol,logar)

### combined_datasets <- egg_database %>% rename(medX1 = X1, medX2 = X2, medvol = vol) %>%
###                     select(ID,medX1,medX2,medvol) %>% na.omit() %>% 
###                     left_join(egg_database_big,by="ID") %>% rename(bigX1 = X1, bigX2 = X2, bigvol = vol) %>% 
###                     select(ID,medX1,medX2,medvol,bigX1,bigX2,bigvol) %>% 
###                     left_join(egg_database_small,by="ID") %>% rename(smallX1 = X1, smallX2 = X2, smallvol = vol) %>% 
###                     select(ID,medvol,smallvol,bigvol) %>% reshape::melt(id.vars="ID")
### 
### big_small_plot <- ggplot(combined_datasets,aes(x = factor(ID,levels = egg_database %>% arrange(vol) %>% pull(ID)), y = value, color = variable)) + geom_point(size=0.5,alpha=0.5) + scale_color_manual(values = c("dark grey", "blue", "red")) + theme(axis.text.x = element_blank()) + scale_y_log10() + xlab("database entries ranked by volume") + ylab("egg volume mm3")
### 
### pdf("big_small_plot.pdf",width=10,height=4)
###     print(big_small_plot)
### dev.off()



